{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-dynamic-connection/webpack/universalModuleDefinition","webpack://@blockly/block-dynamic-connection/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-dynamic-connection/webpack/bootstrap","webpack://@blockly/block-dynamic-connection/webpack/runtime/define property getters","webpack://@blockly/block-dynamic-connection/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/block-dynamic-connection/webpack/runtime/make namespace object","webpack://@blockly/block-dynamic-connection/./src/dynamic_if.ts","webpack://@blockly/block-dynamic-connection/./src/dynamic_text_join.ts","webpack://@blockly/block-dynamic-connection/./src/dynamic_list_create.ts","webpack://@blockly/block-dynamic-connection/./src/connection_previewer.ts","webpack://@blockly/block-dynamic-connection/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a version of the if block with dyanmic\n *     inputs that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Type of a block that has the DYNAMIC_IF_MIXIN. */\ntype DynamicIfBlock = Blockly.Block & DynamicIfMixin;\n/* eslint-disable @typescript-eslint/no-empty-interface */\n/** This interface avoids a \"circular reference\" compile error. */\ninterface DynamicIfMixin extends DynamicIfMixinType {}\n/* eslint-enable @typescript-eslint/no-empty-interface */\ntype DynamicIfMixinType = typeof DYNAMIC_IF_MIXIN;\n\ninterface CaseConnectionPair {\n  ifTarget?: Blockly.Connection | null;\n  doTarget?: Blockly.Connection | null;\n}\n\ninterface CaseInputPair {\n  ifInput: Blockly.Input;\n  doInput: Blockly.Input;\n}\n\n/** Extra state for serializing controls_if blocks. */\ninterface IfExtraState {\n  elseIfCount?: number;\n  hasElse?: boolean;\n}\n\nconst DYNAMIC_IF_MIXIN = {\n  /**\n   * Minimum number of inputs for this block.\n   *\n   * @deprecated This is unused.\n   */\n  minInputs: 1,\n\n  /** Count of else-if cases. */\n  elseifCount: 0,\n\n  /** Count of else cases (either 0 or 1). */\n  elseCount: 0,\n\n  /**\n   * Block for if/elseif/else statements. Must have one if input.\n   * Can have any number of elseif inputs and optionally one else input.\n   */\n  init(this: DynamicIfBlock): void {\n    this.setHelpUrl(Blockly.Msg['CONTROLS_IF_HELPURL']);\n    this.setStyle('logic_blocks');\n    this.addFirstCase();\n    this.setNextStatement(true);\n    this.setPreviousStatement(true);\n    this.setTooltip(Blockly.Msg['LISTS_CREATE_WITH_TOOLTIP']);\n  },\n\n  /**\n   * Create XML to represent if/elseif/else inputs.\n   *\n   * @returns XML storage element.\n   */\n  mutationToDom(this: DynamicIfBlock): Element | null {\n    if (!this.isDeadOrDying()) {\n      // If we call finalizeConnections here without disabling events, we get into\n      // an event loop.\n      Blockly.Events.disable();\n      this.finalizeConnections();\n      if (this instanceof Blockly.BlockSvg) this.initSvg();\n      Blockly.Events.enable();\n    }\n\n    if (!this.elseifCount && !this.elseCount) return null;\n\n    const container = Blockly.utils.xml.createElement('mutation');\n    if (this.elseifCount) {\n      container.setAttribute('elseif', `${this.elseifCount}`);\n    }\n    if (this.elseCount) {\n      container.setAttribute('else', '1');\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the inputs.\n   *\n   * @param xmlElement XML storage element.\n   */\n  domToMutation(this: DynamicIfBlock, xmlElement: Element): void {\n    if (xmlElement.getAttribute('inputs')) {\n      this.deserializeInputs(xmlElement);\n    } else {\n      this.deserializeCounts(xmlElement);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'inputs' attribute (non-standard).\n   *\n   * @param xmlElement XML storage element.\n   */\n  deserializeInputs(this: DynamicIfBlock, xmlElement: Element): void {\n    const inputs = xmlElement.getAttribute('inputs');\n    if (inputs) {\n      const inputNumbers = inputs.split(',');\n      if (this.getInput('IF0')) {\n        this.removeInput('IF0');\n      }\n      if (this.getInput('DO0')) {\n        this.removeInput('DO0');\n      }\n      const first = inputNumbers[0];\n      this.appendValueInput('IF' + first)\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_IF'], 'if');\n      this.appendStatementInput('DO' + first).appendField(\n        Blockly.Msg['CONTROLS_IF_MSG_THEN'],\n      );\n\n      for (let i = 1; i < inputNumbers.length; i++) {\n        this.appendValueInput('IF' + inputNumbers[i])\n          .setCheck('Boolean')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'], 'elseif');\n        this.appendStatementInput('DO' + inputNumbers[i]).appendField(\n          Blockly.Msg['CONTROLS_IF_MSG_THEN'],\n        );\n      }\n    }\n    const hasElse = xmlElement.getAttribute('else');\n    if (hasElse == 'true') {\n      this.addElseInput();\n    }\n  },\n\n  /**\n   * Parses XML based on the 'elseif' and 'else' attributes (standard).\n   *\n   * @param xmlElement XML storage element.\n   */\n  deserializeCounts(this: DynamicIfBlock, xmlElement: Element): void {\n    this.elseifCount =\n      parseInt(xmlElement.getAttribute('elseif') ?? '0', 10) || 0;\n    this.elseCount = parseInt(xmlElement.getAttribute('else') ?? '0', 10) || 0;\n    for (let i = 1; i <= this.elseifCount; i++) {\n      this.insertElseIf(this.inputList.length, i);\n    }\n    if (this.elseCount) {\n      this.addElseInput();\n    }\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @returns The state of this block, ie the else if count and else state.\n   */\n  saveExtraState: function (this: DynamicIfBlock): IfExtraState | null {\n    if (!this.isDeadOrDying() && !this.isCorrectlyFormatted()) {\n      // If we call finalizeConnections here without disabling events, we get into\n      // an event loop.\n      Blockly.Events.disable();\n      this.finalizeConnections();\n      if (this instanceof Blockly.BlockSvg) this.initSvg();\n      Blockly.Events.enable();\n    }\n\n    if (!this.elseifCount && !this.elseCount) {\n      return null;\n    }\n    const state = Object.create(null);\n    if (this.elseifCount) {\n      state['elseIfCount'] = this.elseifCount;\n    }\n    if (this.elseCount) {\n      state['hasElse'] = true;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, ie the else if count\n   *     and else state.\n   */\n  loadExtraState: function (\n    this: DynamicIfBlock,\n    state: IfExtraState | string,\n  ) {\n    if (typeof state === 'string') {\n      this.domToMutation(Blockly.utils.xml.textToDom(state));\n      return;\n    }\n\n    this.elseifCount = state['elseIfCount'] || 0;\n    this.elseCount = state['hasElse'] ? 1 : 0;\n    for (let i = 1; i <= this.elseifCount; i++) {\n      this.insertElseIf(this.inputList.length, i);\n    }\n    if (this.elseCount) {\n      this.addElseInput();\n    }\n  },\n\n  /**\n   * Finds the index of a connection. Used to determine where in the block to\n   * insert new inputs.\n   *\n   * @param connection A connection on this block.\n   * @returns The index of the connection in the this.inputList.\n   */\n  findInputIndexForConnection(\n    this: DynamicIfBlock,\n    connection: Blockly.Connection,\n  ): number | null {\n    if (\n      !connection.targetConnection ||\n      connection.targetBlock()?.isInsertionMarker()\n    ) {\n      // This connection is available.\n      return null;\n    }\n    for (let i = 0; i < this.inputList.length; i++) {\n      const input = this.inputList[i];\n      if (input.connection == connection) {\n        return i;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Inserts a boolean value input and statement input at the specified index.\n   *\n   * @param index Index of the input before which to add new inputs.\n   * @param id An ID to append to the case statement input names to make them\n   *     unique.\n   * @returns The added inputs.\n   */\n  insertElseIf(\n    this: DynamicIfBlock,\n    index: number,\n    id: string | number,\n  ): CaseInputPair {\n    const ifInput = this.appendValueInput('IF' + id)\n      .setCheck('Boolean')\n      .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'], 'elseif');\n    const doInput = this.appendStatementInput('DO' + id).appendField(\n      Blockly.Msg['CONTROLS_IF_MSG_THEN'],\n    );\n    this.moveInputBefore('IF' + id, this.inputList[index].name);\n    this.moveInputBefore('DO' + id, this.inputList[index + 1].name);\n    return {ifInput, doInput};\n  },\n\n  /**\n   * Called by a monkey-patched version of InsertionMarkerManager when\n   * a block is dragged over one of the connections on this block.\n   *\n   * @param connection The connection on this block that has a pending\n   *     connection.\n   */\n  onPendingConnection(\n    this: DynamicIfBlock,\n    connection: Blockly.Connection,\n  ): void {\n    if (connection.type === Blockly.NEXT_STATEMENT && !this.getInput('ELSE')) {\n      this.addElseInput();\n    }\n    const inputIndex = this.findInputIndexForConnection(connection);\n    if (inputIndex === null) {\n      return;\n    }\n    const input = this.inputList[inputIndex];\n    if (input.name.includes('IF')) {\n      const nextIfInput = this.inputList[inputIndex + 2];\n      if (!nextIfInput || nextIfInput.name == 'ELSE') {\n        this.insertElseIf(inputIndex + 2, Blockly.utils.idGenerator.genUid());\n      } else {\n        const nextIfConnection =\n          nextIfInput &&\n          nextIfInput.connection &&\n          nextIfInput.connection.targetConnection;\n        if (\n          nextIfConnection &&\n          !nextIfConnection.getSourceBlock().isInsertionMarker()\n        ) {\n          this.insertElseIf(inputIndex + 2, Blockly.utils.idGenerator.genUid());\n        }\n      }\n    }\n  },\n\n  /**\n   * Called by a monkey-patched version of InsertionMarkerManager when a block\n   * drag ends if the dragged block had a pending connection with this block.\n   */\n  finalizeConnections(this: DynamicIfBlock): void {\n    const targetCaseConns = this.collectTargetCaseConns();\n    const targetElseConn = this.getInput('ELSE')?.connection?.targetConnection;\n\n    this.tearDownBlock();\n\n    this.addFirstCase();\n    this.addCaseInputs(targetCaseConns);\n    if (targetElseConn) {\n      this.addElseInput().connection?.connect(targetElseConn);\n    }\n\n    this.elseifCount = Math.max(targetCaseConns.length - 1, 0);\n    this.elseCount = targetElseConn ? 1 : 0;\n  },\n\n  /**\n   * Collects all of the target blocks attached to case inputs. If neither the\n   * if nor the due input in a case has an attached block, that input is\n   * skipped. If only one of them has an attached block, the other value in\n   * the pair is undefined.\n   *\n   * @returns  A list of target connections attached to case inputs.\n   */\n  collectTargetCaseConns(this: DynamicIfBlock): CaseConnectionPair[] {\n    const targetConns = [];\n    for (let i = 0; i < this.inputList.length - 1; i += 2) {\n      const ifTarget = this.inputList[i].connection?.targetConnection;\n      const doTarget = this.inputList[i + 1].connection?.targetConnection;\n      if (!ifTarget && !doTarget) continue;\n      targetConns.push({ifTarget, doTarget});\n    }\n    return targetConns;\n  },\n\n  /** Deletes all inputs on the block so it can be rebuilt. */\n  tearDownBlock(this: DynamicIfBlock): void {\n    for (let i = this.inputList.length - 1; i >= 0; i--) {\n      this.removeInput(this.inputList[i].name);\n    }\n  },\n\n  /**\n   * Adds inputs for all of the given target connection pairs (if the input\n   * doesn't already exist), and connects the target connections to them.\n   *\n   * This is essentially rebuilding all of the cases with strictly ascending\n   * case numbers.\n   *\n   * @param targetConns The list of target connections to attach to this block.\n   */\n  addCaseInputs(this: DynamicIfBlock, targetConns: CaseConnectionPair[]): void {\n    for (let i = 0; i < targetConns.length; i++) {\n      let ifInput = this.getInput(`IF${i}`);\n      let doInput = this.getInput(`DO${i}`);\n      if (!ifInput || !doInput) {\n        ({ifInput, doInput} = this.insertElseIf(i * 2, i));\n      }\n\n      const {ifTarget, doTarget} = targetConns[i];\n      if (ifTarget) ifInput.connection?.connect(ifTarget);\n      if (doTarget) doInput.connection?.connect(doTarget);\n    }\n  },\n\n  /**\n   * Adds an else input to this block.\n   *\n   * @returns The appended input.\n   */\n  addElseInput(this: DynamicIfBlock): Blockly.Input {\n    return this.appendStatementInput('ELSE').appendField(\n      Blockly.Msg['CONTROLS_IF_MSG_ELSE'],\n    );\n  },\n\n  /**\n   * Adds the first 'IF' and 'DO' inputs and their associated labels to this\n   * block.\n   */\n  addFirstCase(this: DynamicIfBlock): void {\n    this.appendValueInput('IF0')\n      .setCheck('Boolean')\n      .appendField(Blockly.Msg['CONTROLS_IF_MSG_IF'], 'if');\n    this.appendStatementInput('DO0').appendField(\n      Blockly.Msg['CONTROLS_IF_MSG_THEN'],\n    );\n  },\n\n  /**\n   * Returns true if all of the inputs on this block are in order.\n   * False otherwise.\n   */\n  isCorrectlyFormatted(this: DynamicIfBlock): boolean {\n    for (let i = 0; i < this.inputList.length - 1; i += 2) {\n      if (this.inputList[i].name !== `IF${i}`) return false;\n      if (this.inputList[i + 1].name !== `DO${i}`) return false;\n    }\n    return true;\n  },\n};\n\nBlockly.Blocks['dynamic_if'] = DYNAMIC_IF_MIXIN;\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a version of the text_join block with dyanmic\n *    inputs that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Type of a block that has the DYNAMIC_TEXT_JOIN_MIXIN. */\ntype DynamicTextJoinBlock = Blockly.Block & DynamicTextJoinMixin;\n/* eslint-disable @typescript-eslint/no-empty-interface */\n/** This interface avoids a \"circular reference\" compile error. */\ninterface DynamicTextJoinMixin extends DynamicTextJoinMixinType {}\n/* eslint-enable @typescript-eslint/no-empty-interface */\ntype DynamicTextJoinMixinType = typeof DYNAMIC_TEXT_JOIN_MIXIN;\n\nconst DYNAMIC_TEXT_JOIN_MIXIN = {\n  /** Minimum number of inputs for this block. */\n  minInputs: 2,\n\n  /** Count of the item inputs. */\n  itemCount: 0,\n\n  /** Block for concatenating any number of strings. */\n  init(this: DynamicTextJoinBlock): void {\n    this.itemCount = this.minInputs;\n\n    this.setHelpUrl(Blockly.Msg['TEXT_JOIN_HELPURL']);\n    this.setStyle('text_blocks');\n    this.addFirstInput();\n    for (let i = 1; i < this.minInputs; i++) this.appendValueInput(`ADD${i}`);\n    this.setOutput(true, 'String');\n    this.setTooltip(Blockly.Msg['TEXT_JOIN_TOOLTIP']);\n  },\n\n  /**\n   * Create XML to represent number of text inputs.\n   *\n   * @returns XML storage element.\n   */\n  mutationToDom(this: DynamicTextJoinBlock): Element {\n    if (!this.isDeadOrDying()) {\n      // If we call finalizeConnections here without disabling events, we get into\n      // an event loop.\n      Blockly.Events.disable();\n      this.finalizeConnections();\n      if (this instanceof Blockly.BlockSvg) this.initSvg();\n      Blockly.Events.enable();\n    }\n\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', `${this.itemCount}`);\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the text inputs.\n   *\n   * @param xmlElement XML storage element.\n   */\n  domToMutation(this: DynamicTextJoinBlock, xmlElement: Element): void {\n    if (xmlElement.getAttribute('inputs')) {\n      this.deserializeInputs(xmlElement);\n    } else {\n      this.deserializeCounts(xmlElement);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'inputs' attribute (non-standard).\n   *\n   * @param xmlElement XML storage element.\n   */\n  deserializeInputs(this: DynamicTextJoinBlock, xmlElement: Element): void {\n    const items = xmlElement.getAttribute('inputs');\n    if (items) {\n      const inputNames = items.split(',');\n      this.inputList = [];\n      inputNames.forEach((name) => this.appendValueInput(name));\n      this.inputList[0].appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'items' attribute (standard).\n   *\n   * @param xmlElement XML storage element.\n   */\n  deserializeCounts(this: DynamicTextJoinBlock, xmlElement: Element): void {\n    this.itemCount = Math.max(\n      parseInt(xmlElement.getAttribute('items') ?? '0', 10),\n      this.minInputs,\n    );\n    // minInputs are added automatically.\n    for (let i = this.minInputs; i < this.itemCount; i++) {\n      this.appendValueInput('ADD' + i);\n    }\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @returns The state of this block, ie the item count.\n   */\n  saveExtraState: function (this: DynamicTextJoinBlock): {itemCount: number} {\n    if (!this.isDeadOrDying() && !this.isCorrectlyFormatted()) {\n      // If we call finalizeConnections here without disabling events, we get into\n      // an event loop.\n      Blockly.Events.disable();\n      this.finalizeConnections();\n      if (this instanceof Blockly.BlockSvg) this.initSvg();\n      Blockly.Events.enable();\n    }\n\n    return {\n      itemCount: this.itemCount,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function (\n    this: DynamicTextJoinBlock,\n    state: {itemCount?: number; [x: string]: unknown} | string,\n  ) {\n    if (typeof state === 'string') {\n      this.domToMutation(Blockly.utils.xml.textToDom(state));\n      return;\n    }\n\n    this.itemCount = state['itemCount'] ?? 0;\n    // minInputs are added automatically.\n    for (let i = this.minInputs; i < this.itemCount; i++) {\n      this.appendValueInput('ADD' + i);\n    }\n  },\n\n  /**\n   * Check whether a new input should be added and determine where it should go.\n   *\n   * @param connection The connection that has a pending connection.\n   * @returns The index before which to insert a new input, or null if no input\n   *     should be added.\n   */\n  findInputIndexForConnection(\n    this: DynamicTextJoinBlock,\n    connection: Blockly.Connection,\n  ): number | null {\n    if (\n      !connection.targetConnection ||\n      connection.targetBlock()?.isInsertionMarker()\n    ) {\n      // This connection is available.\n      return null;\n    }\n\n    let connectionIndex = -1;\n    for (let i = 0; i < this.inputList.length; i++) {\n      if (this.inputList[i].connection == connection) {\n        connectionIndex = i;\n      }\n    }\n\n    if (connectionIndex == this.inputList.length - 1) {\n      // This connection is the last one and already has a block in it, so\n      // we should add a new connection at the end.\n      return this.inputList.length + 1;\n    }\n\n    const nextInput = this.inputList[connectionIndex + 1];\n    const nextConnection = nextInput?.connection?.targetConnection;\n    if (\n      nextConnection &&\n      !nextConnection.getSourceBlock().isInsertionMarker()\n    ) {\n      return connectionIndex + 1;\n    }\n\n    // Don't add new connection.\n    return null;\n  },\n\n  /**\n   * Called by a monkey-patched version of InsertionMarkerManager when\n   * a block is dragged over one of the connections on this block.\n   *\n   * @param connection The connection on this block that has a pending\n   *     connection.\n   */\n  onPendingConnection(\n    this: DynamicTextJoinBlock,\n    connection: Blockly.Connection,\n  ): void {\n    const insertIndex = this.findInputIndexForConnection(connection);\n    if (insertIndex == null) {\n      return;\n    }\n    this.appendValueInput(`ADD${Blockly.utils.idGenerator.genUid()}`);\n    this.moveNumberedInputBefore(this.inputList.length - 1, insertIndex);\n  },\n\n  /**\n   * Called by a monkey-patched version of InsertionMarkerManager when a block\n   * drag ends if the dragged block had a pending connection with this block.\n   */\n  finalizeConnections(this: DynamicTextJoinBlock): void {\n    const targetConns = this.removeUnnecessaryEmptyConns(\n      this.inputList.map((i) => i.connection?.targetConnection),\n    );\n    this.tearDownBlock();\n    this.addItemInputs(targetConns);\n    this.itemCount = targetConns.length;\n  },\n\n  /** Deletes all inputs on this block so it can be rebuilt. */\n  tearDownBlock(this: DynamicTextJoinBlock): void {\n    for (let i = this.inputList.length - 1; i >= 0; i--) {\n      this.removeInput(this.inputList[i].name);\n    }\n  },\n\n  /**\n   * Filters the given target connections so that empty connections are removed,\n   * unless we need those to reach the minimum input count. Empty connections\n   * are removed starting at the end of the array.\n   *\n   * @param targetConns The list of connections associated with inputs.\n   * @returns A filtered list of connections (or null/undefined) which should\n   *     be attached to inputs.\n   */\n  removeUnnecessaryEmptyConns(\n    this: DynamicTextJoinBlock,\n    targetConns: Array<Blockly.Connection | undefined | null>,\n  ): Array<Blockly.Connection | undefined | null> {\n    const filteredConns = [...targetConns];\n    for (let i = filteredConns.length - 1; i >= 0; i--) {\n      if (!filteredConns[i] && filteredConns.length > this.minInputs) {\n        filteredConns.splice(i, 1);\n      }\n    }\n    return filteredConns;\n  },\n\n  /**\n   * Adds inputs based on the given array of target conns. An input is added for\n   * every entry in the array (if it does not already exist). If the entry is\n   * a connection and not null/undefined the connection will be connected to\n   * the input.\n   *\n   * @param targetConns The connections defining the inputs to add.\n   */\n  addItemInputs(\n    this: DynamicTextJoinBlock,\n    targetConns: Array<Blockly.Connection | undefined | null>,\n  ): void {\n    const input = this.addFirstInput();\n    const firstConn = targetConns[0];\n    if (firstConn) input.connection?.connect(firstConn);\n\n    for (let i = 1; i < targetConns.length; i++) {\n      const input = this.appendValueInput(`ADD${i}`);\n\n      const targetConn = targetConns[i];\n      if (targetConn) input.connection?.connect(targetConn);\n    }\n  },\n\n  /**\n   * Adds the top input with the label to this block.\n   *\n   * @returns The added input.\n   */\n  addFirstInput(this: DynamicTextJoinBlock): Blockly.Input {\n    return this.appendValueInput('ADD0').appendField(\n      Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH'],\n    );\n  },\n\n  /**\n   * Returns true if all of the inputs on this block are in order.\n   * False otherwise.\n   */\n  isCorrectlyFormatted(this: DynamicTextJoinBlock): boolean {\n    for (let i = 0; i < this.inputList.length; i++) {\n      if (this.inputList[i].name !== `ADD${i}`) return false;\n    }\n    return true;\n  },\n};\n\nBlockly.Blocks['dynamic_text_join'] = DYNAMIC_TEXT_JOIN_MIXIN;\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a version of the list_create block with dyanmic\n *     inputs that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Type of a block that has the DYNAMIC_LIST_CREATE_MIXIN. */\ntype DynamicListCreateBlock = Blockly.Block & DynamicListCreateMixin;\n/* eslint-disable @typescript-eslint/no-empty-interface */\n/** This interface avoids a \"circular reference\" compile error. */\ninterface DynamicListCreateMixin extends DynamicListCreateMixinType {}\n/* eslint-enable @typescript-eslint/no-empty-interface */\ntype DynamicListCreateMixinType = typeof DYNAMIC_LIST_CREATE_MIXIN;\n\nconst DYNAMIC_LIST_CREATE_MIXIN = {\n  /** Minimum number of inputs for this block. */\n  minInputs: 2,\n\n  /** Count of item inputs. */\n  itemCount: 0,\n\n  /** Block for concatenating any number of strings. */\n  init(this: DynamicListCreateBlock): void {\n    this.itemCount = this.minInputs;\n\n    this.setHelpUrl(Blockly.Msg['LISTS_CREATE_WITH_HELPURL']);\n    this.setStyle('list_blocks');\n    this.addFirstInput();\n    for (let i = 1; i < this.minInputs; i++) {\n      this.appendValueInput(`ADD${i}`);\n    }\n    this.setOutput(true, 'Array');\n    this.setTooltip(Blockly.Msg['LISTS_CREATE_WITH_TOOLTIP']);\n  },\n\n  /**\n   * Create XML to represent number of text inputs.\n   *\n   * @returns XML storage element.\n   */\n  mutationToDom(this: DynamicListCreateBlock): Element {\n    if (!this.isDeadOrDying()) {\n      // If we call finalizeConnections here without disabling events, we get into\n      // an event loop.\n      Blockly.Events.disable();\n      this.finalizeConnections();\n      if (this instanceof Blockly.BlockSvg) this.initSvg();\n      Blockly.Events.enable();\n    }\n\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', `${this.itemCount}`);\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the text inputs.\n   *\n   * @param xmlElement XML storage element.\n   */\n  domToMutation(this: DynamicListCreateBlock, xmlElement: Element): void {\n    if (xmlElement.getAttribute('inputs')) {\n      this.deserializeInputs(xmlElement);\n    } else {\n      this.deserializeCounts(xmlElement);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'inputs' attribute (non-standard).\n   *\n   * @param xmlElement XML storage element.\n   */\n  deserializeInputs(this: DynamicListCreateBlock, xmlElement: Element): void {\n    const items = xmlElement.getAttribute('inputs');\n    if (items) {\n      const inputNames = items.split(',');\n      this.inputList = [];\n      inputNames.forEach((name) => this.appendValueInput(name));\n      this.inputList[0].appendField(\n        Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH'],\n      );\n    }\n  },\n\n  /**\n   * Parses XML based on the 'items' attribute (standard).\n   *\n   * @param xmlElement XML storage element.\n   */\n  deserializeCounts(this: DynamicListCreateBlock, xmlElement: Element): void {\n    this.itemCount = Math.max(\n      parseInt(xmlElement.getAttribute('items') ?? '0', 10),\n      this.minInputs,\n    );\n    // minInputs are added automatically.\n    for (let i = this.minInputs; i < this.itemCount; i++) {\n      this.appendValueInput('ADD' + i);\n    }\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @returns The state of this block, ie the item count.\n   */\n  saveExtraState: function (this: DynamicListCreateBlock): {itemCount: number} {\n    if (!this.isDeadOrDying() && !this.isCorrectlyFormatted()) {\n      // If we call finalizeConnections here without disabling events, we get\n      // into an event loop.\n      Blockly.Events.disable();\n      this.finalizeConnections();\n      if (this instanceof Blockly.BlockSvg) this.initSvg();\n      Blockly.Events.enable();\n    }\n\n    return {\n      itemCount: this.itemCount,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function (\n    this: DynamicListCreateBlock,\n    state: {itemCount?: number; [x: string]: unknown} | string,\n  ) {\n    if (typeof state === 'string') {\n      this.domToMutation(Blockly.utils.xml.textToDom(state));\n      return;\n    }\n\n    this.itemCount = state['itemCount'] ?? 0;\n    // minInputs are added automatically.\n    for (let i = this.minInputs; i < this.itemCount; i++) {\n      this.appendValueInput('ADD' + i);\n    }\n  },\n\n  /**\n   * Check whether a new input should be added and determine where it should go.\n   *\n   * @param connection The connection that has a pending connection.\n   * @returns The index before which to insert a new input, or null if no input\n   *     should be added.\n   */\n  findInputIndexForConnection(\n    this: DynamicListCreateBlock,\n    connection: Blockly.Connection,\n  ): number | null {\n    if (\n      !connection.targetConnection ||\n      connection.targetBlock()?.isInsertionMarker()\n    ) {\n      // This connection is available.\n      return null;\n    }\n\n    let connectionIndex = -1;\n    for (let i = 0; i < this.inputList.length; i++) {\n      if (this.inputList[i].connection == connection) {\n        connectionIndex = i;\n      }\n    }\n\n    if (connectionIndex == this.inputList.length - 1) {\n      // This connection is the last one and already has a block in it, so\n      // we should add a new connection at the end.\n      return this.inputList.length + 1;\n    }\n\n    const nextInput = this.inputList[connectionIndex + 1];\n    const nextConnection = nextInput?.connection?.targetConnection;\n    if (\n      nextConnection &&\n      !nextConnection.getSourceBlock().isInsertionMarker()\n    ) {\n      return connectionIndex + 1;\n    }\n\n    // Don't add new connection.\n    return null;\n  },\n\n  /**\n   * Called by a monkey-patched version of InsertionMarkerManager when\n   * a block is dragged over one of the connections on this block.\n   *\n   * @param connection The connection on this block that has a pending\n   *     connection.\n   */\n  onPendingConnection(\n    this: DynamicListCreateBlock,\n    connection: Blockly.Connection,\n  ): void {\n    const insertIndex = this.findInputIndexForConnection(connection);\n    if (insertIndex == null) {\n      return;\n    }\n    this.appendValueInput(`ADD${Blockly.utils.idGenerator.genUid()}`);\n    this.moveNumberedInputBefore(this.inputList.length - 1, insertIndex);\n  },\n\n  /**\n   * Called by a monkey-patched version of InsertionMarkerManager when a block\n   * drag ends if the dragged block had a pending connection with this block.\n   */\n  finalizeConnections(this: DynamicListCreateBlock): void {\n    const targetConns = this.removeUnnecessaryEmptyConns(\n      this.inputList.map((i) => i.connection?.targetConnection),\n    );\n    this.tearDownBlock();\n    this.addItemInputs(targetConns);\n    this.itemCount = targetConns.length;\n  },\n\n  /** Deletes all inputs on the block so it can be rebuilt. */\n  tearDownBlock(this: DynamicListCreateBlock): void {\n    for (let i = this.inputList.length - 1; i >= 0; i--) {\n      this.removeInput(this.inputList[i].name);\n    }\n  },\n\n  /**\n   * Filters the given target connections so that empty connections are removed,\n   * unless we need those to reach the minimum input count. Empty connections\n   * are removed starting at the end of the array.\n   *\n   * @param targetConns The list of connections associated with inputs.\n   * @returns A filtered list of connections (or null/undefined) which should\n   *     be attached to inputs.\n   */\n  removeUnnecessaryEmptyConns(\n    targetConns: Array<Blockly.Connection | undefined | null>,\n  ): Array<Blockly.Connection | undefined | null> {\n    const filteredConns = [...targetConns];\n    for (let i = filteredConns.length - 1; i >= 0; i--) {\n      if (!filteredConns[i] && filteredConns.length > this.minInputs) {\n        filteredConns.splice(i, 1);\n      }\n    }\n    return filteredConns;\n  },\n\n  /**\n   * Adds inputs based on the given array of target cons. An input is added for\n   * every entry in the array (if it does not already exist). If the entry is\n   * a connection and not null/undefined the connection will be connected to\n   * the input.\n   *\n   * @param targetConns The connections defining the inputs to add.\n   */\n  addItemInputs(\n    this: DynamicListCreateBlock,\n    targetConns: Array<Blockly.Connection | undefined | null>,\n  ): void {\n    const input = this.addFirstInput();\n    const firstConn = targetConns[0];\n    if (firstConn) input.connection?.connect(firstConn);\n\n    for (let i = 1; i < targetConns.length; i++) {\n      const input = this.appendValueInput(`ADD${i}`);\n\n      const targetConn = targetConns[i];\n      if (targetConn) input.connection?.connect(targetConn);\n    }\n  },\n\n  /**\n   * Adds the top input with the label to this block.\n   *\n   * @returns The added input.\n   */\n  addFirstInput(this: DynamicListCreateBlock): Blockly.Input {\n    return this.appendValueInput('ADD0').appendField(\n      Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH'],\n    );\n  },\n\n  /**\n   * Returns true if all of the inputs on this block are in order.\n   * False otherwise.\n   */\n  isCorrectlyFormatted(this: DynamicListCreateBlock): boolean {\n    for (let i = 0; i < this.inputList.length; i++) {\n      if (this.inputList[i].name !== `ADD${i}`) return false;\n    }\n    return true;\n  },\n};\n\nBlockly.Blocks['dynamic_list_create'] = DYNAMIC_LIST_CREATE_MIXIN;\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\ninterface ConnectionPreviewerConstructor {\n  new (draggedBlock: Blockly.BlockSvg): Blockly.IConnectionPreviewer;\n}\n\ninterface DynamicBlock extends Blockly.BlockSvg {\n  onPendingConnection(connection: Blockly.RenderedConnection): void;\n  finalizeConnections(): void;\n}\n\n/**\n * A type guard that checks if the given block fulfills the DynamicBlock\n * interface.\n *\n * @param block\n */\nexport function blockIsDynamic(block: Blockly.BlockSvg): block is DynamicBlock {\n  return (\n    (block as DynamicBlock)['onPendingConnection'] !== undefined &&\n    (block as DynamicBlock)['finalizeConnections'] !== undefined\n  );\n}\n\n/**\n * Returns a connection previewer constructor that decorates the passed\n * constructor to add connection previewing.\n *\n * @param BasePreviewerConstructor The constructor for the base connection\n *     previewer class being decorated. If not provided, the default\n *     InsertionMarkerPreviewer will be used.\n * @return A decorated connection previewer constructor.\n */\nexport function decoratePreviewer(\n  BasePreviewerConstructor?: ConnectionPreviewerConstructor,\n): ConnectionPreviewerConstructor {\n  return class implements Blockly.IConnectionPreviewer {\n    private basePreviewer: Blockly.IConnectionPreviewer;\n\n    private pendingBlocks: Set<DynamicBlock> = new Set();\n\n    constructor(draggedBlock: Blockly.BlockSvg) {\n      const BaseConstructor =\n        BasePreviewerConstructor ?? Blockly.InsertionMarkerPreviewer;\n      this.basePreviewer = new BaseConstructor(draggedBlock);\n    }\n\n    previewReplacement(\n      draggedConn: Blockly.RenderedConnection,\n      staticConn: Blockly.RenderedConnection,\n      replacedBlock: Blockly.BlockSvg,\n    ): void {\n      this.previewDynamism(staticConn);\n      this.basePreviewer.previewReplacement(\n        draggedConn,\n        staticConn,\n        replacedBlock,\n      );\n    }\n\n    previewConnection(\n      draggedConn: Blockly.RenderedConnection,\n      staticConn: Blockly.RenderedConnection,\n    ): void {\n      this.previewDynamism(staticConn);\n      this.basePreviewer.previewConnection(draggedConn, staticConn);\n    }\n\n    hidePreview(): void {\n      this.basePreviewer.hidePreview();\n    }\n\n    dispose(): void {\n      for (const block of this.pendingBlocks) {\n        if (block.isDeadOrDying()) return;\n        block.finalizeConnections();\n      }\n      this.pendingBlocks.clear();\n      this.basePreviewer.dispose();\n    }\n\n    /**\n     * If the block is a dynamic block, calls onPendingConnection and\n     * stores the block to be finalized later.\n     *\n     * @param conn The block to trigger onPendingConnection on.\n     */\n    private previewDynamism(conn: Blockly.RenderedConnection) {\n      const block = conn.getSourceBlock();\n      if (blockIsDynamic(block)) {\n        block.onPendingConnection(conn);\n        this.pendingBlocks.add(block);\n      }\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Adds blocks that replace the built-in mutator UI with dynamic\n *     connections that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\nimport './dynamic_if';\nimport './dynamic_text_join';\nimport './dynamic_list_create';\nimport {decoratePreviewer, blockIsDynamic} from './connection_previewer';\n\nexport {decoratePreviewer, blockIsDynamic};\n\nexport const overrideOldBlockDefinitions = function (): void {\n  Blockly.Blocks['lists_create_with'] = Blockly.Blocks['dynamic_list_create'];\n  Blockly.Blocks['text_join'] = Blockly.Blocks['dynamic_text_join'];\n  Blockly.Blocks['controls_if'] = Blockly.Blocks['dynamic_if'];\n};\n\n/**\n * Finalizes connections when certain events (such as block deletion) are\n * detected.\n *\n * @param e\n */\nexport function finalizeConnections(e: Blockly.Events.Abstract) {\n  if (e.type === Blockly.Events.BLOCK_DELETE) {\n    const ws = Blockly.Workspace.getById(e.workspaceId ?? '');\n    if (!ws) return;\n    for (const block of ws.getAllBlocks() as Blockly.BlockSvg[]) {\n      if (blockIsDynamic(block)) {\n        block.finalizeConnections();\n      }\n    }\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","DYNAMIC_IF_MIXIN","minInputs","elseifCount","elseCount","init","setHelpUrl","setStyle","addFirstCase","setNextStatement","setPreviousStatement","setTooltip","mutationToDom","isDeadOrDying","disable","finalizeConnections","initSvg","enable","container","xml","createElement","setAttribute","domToMutation","xmlElement","getAttribute","deserializeInputs","deserializeCounts","inputs","inputNumbers","split","getInput","removeInput","first","appendValueInput","setCheck","appendField","appendStatementInput","length","addElseInput","parseInt","insertElseIf","inputList","saveExtraState","isCorrectlyFormatted","state","create","loadExtraState","textToDom","findInputIndexForConnection","connection","targetConnection","targetBlock","isInsertionMarker","index","id","ifInput","doInput","moveInputBefore","name","onPendingConnection","type","inputIndex","includes","nextIfInput","nextIfConnection","getSourceBlock","idGenerator","genUid","targetCaseConns","collectTargetCaseConns","targetElseConn","tearDownBlock","addCaseInputs","connect","Math","max","targetConns","ifTarget","doTarget","push","DYNAMIC_TEXT_JOIN_MIXIN","itemCount","addFirstInput","setOutput","items","inputNames","forEach","connectionIndex","nextInput","nextConnection","insertIndex","moveNumberedInputBefore","removeUnnecessaryEmptyConns","map","addItemInputs","filteredConns","splice","input","firstConn","targetConn","DYNAMIC_LIST_CREATE_MIXIN","blockIsDynamic","block","decoratePreviewer","BasePreviewerConstructor","constructor","draggedBlock","pendingBlocks","Set","BaseConstructor","basePreviewer","previewReplacement","draggedConn","staticConn","replacedBlock","previewDynamism","previewConnection","hidePreview","dispose","clear","conn","add","overrideOldBlockDefinitions","e","BLOCK_DELETE","ws","getById","workspaceId","getAllBlocks"],"sourceRoot":""}